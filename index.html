<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Image Tile Processor</title>
  <style>
    canvas {
  border: 1px solid #ccc;
  display: block;
  margin-top: 1em;
  max-height: 90vh;
  width: auto;
  height: auto;
  cursor: zoom-in;
  margin-left: auto;
  margin-right: auto;
}
    label, input, button { margin: 0.5em; }
    #status { margin: 1em 0; font-style: italic; color: gray; }
    #fullscreenCanvas {
      position: fixed;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }
    #fullscreenCanvas canvas {
      box-shadow: 0 0 20px black;
      max-width: 100%;
      max-height: 100%;
      cursor: zoom-out;
    }
  </style>
</head>
<body>
  <h2>Upload Image and Process as Tiled Output</h2>
  <input type="file" id="upload" accept="image/*">
  <label for="tilesX">Tiles across:</label>
  <input type="number" id="tilesX" value="10" min="1">
  <button id="processBtn" onclick="processImage()" disabled>Process Image</button>
  <div id="status">Loading palette...</div>
  <canvas id="preview"></canvas>
  <div id="fullscreenCanvas" style="display:none" onclick="hideFullImage()"></div>

  <script>
    let palette = [];
    let imageReady = false;
    let paletteReady = false;
    let inputImage;

    const processBtn = document.getElementById('processBtn');
    const status = document.getElementById('status');
    const preview = document.getElementById('preview');

    function checkReady() {
      if (imageReady && paletteReady) {
        processBtn.disabled = false;
        status.textContent = "Ready to process.";
      } else if (!paletteReady) {
        status.textContent = "Loading palette...";
      } else {
        status.textContent = "Waiting for image upload...";
      }
    }

    fetch('palette.json')
      .then(response => response.json())
      .then(data => {
        palette = data;
        paletteReady = true;
        checkReady();
      })
      .catch(error => {
        status.textContent = "Failed to load palette.";
        console.error("Error loading palette:", error);
      });

    let originalCanvas = document.createElement('canvas');
    let originalCtx = originalCanvas.getContext('2d');

    document.getElementById('upload').addEventListener('change', function (e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function (event) {
        inputImage = new Image();
        inputImage.onload = () => {
          originalCanvas.width = inputImage.width;
          originalCanvas.height = inputImage.height;
          originalCtx.drawImage(inputImage, 0, 0);
          imageReady = true;
          checkReady();
        };
        inputImage.src = event.target.result;
      };
      reader.readAsDataURL(file);
    });

    function averageColor(data, startX, startY, tileW, tileH, imgWidth) {
      let r = 0, g = 0, b = 0, count = 0;
      for (let y = startY; y < startY + tileH; y++) {
        for (let x = startX; x < startX + tileW; x++) {
          let idx = (y * imgWidth + x) * 4;
          r += data[idx];
          g += data[idx + 1];
          b += data[idx + 2];
          count++;
        }
      }
      return { r: r / count, g: g / count, b: b / count };
    }

    function findClosestColor(color) {
      let bestMatch = palette[0];
      let minDist = Infinity;
      for (const p of palette) {
        let dist = (p.r - color.r) ** 2 + (p.g - color.g) ** 2 + (p.b - color.b) ** 2;
        if (dist < minDist) {
          minDist = dist;
          bestMatch = p;
        }
      }
      return bestMatch;
    }

    function getTextColor(r, g, b) {
      const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
      return luminance > 140 ? "black" : "white";
    }

    function processImage() {
      const tileW = 120;
      const tileH = 160;
      const tilesX = parseInt(document.getElementById('tilesX').value);
      const scaledW = tileW * tilesX;
      const scale = scaledW / inputImage.width;
      const scaledH = inputImage.height * scale;
      const tilesY = Math.floor(scaledH / tileH);
      const cropH = tilesY * tileH;
      const offsetY = (scaledH - cropH) / 2;

      const scaledCanvas = document.createElement('canvas');
      scaledCanvas.width = scaledW;
      scaledCanvas.height = cropH;
      const scaledCtx = scaledCanvas.getContext('2d');
      scaledCtx.drawImage(inputImage, 0, -offsetY, scaledW, scaledH);
      const imageData = scaledCtx.getImageData(0, 0, scaledW, cropH).data;

      preview.width = scaledW;
      preview.height = cropH;
      const pctx = preview.getContext('2d');

      const longestName = palette.reduce((a, b) => a.name.length > b.name.length ? a : b).name;
      let fontSize = tileW;
      do {
        fontSize--;
        pctx.font = `${fontSize}px sans-serif`;
      } while (pctx.measureText(longestName).width > tileW - 8);

      pctx.textAlign = "center";
      pctx.textBaseline = "top";

      for (let ty = 0; ty < tilesY; ty++) {
        for (let tx = 0; tx < tilesX; tx++) {
          const x = tx * tileW;
          const y = ty * tileH;
          const avg = averageColor(imageData, x, y, tileW, tileH, scaledW);
          const best = findClosestColor(avg);

          pctx.fillStyle = `rgb(${best.r},${best.g},${best.b})`;
          pctx.fillRect(x, y, tileW, tileH);

          pctx.fillStyle = getTextColor(best.r, best.g, best.b);
          pctx.fillText(best.name, x + tileW / 2, y + 4);
        }
      }

      preview.onclick = () => showFullImage(preview);
    }

    function showFullImage(canvas) {
  const full = document.getElementById('fullscreenCanvas');
  full.innerHTML = '';
  const fullCanvas = document.createElement('canvas');
  fullCanvas.width = canvas.width;
  fullCanvas.height = canvas.height;
  fullCanvas.style.width = canvas.width + 'px';
  fullCanvas.style.height = canvas.height + 'px';
  fullCanvas.getContext('2d').drawImage(canvas, 0, 0);
  full.appendChild(fullCanvas);
  full.style.display = 'flex';
}

    function hideFullImage() {
      const full = document.getElementById('fullscreenCanvas');
      full.innerHTML = '';
      full.style.display = 'none';
    }
  </script>
</body>
</html>
