<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Image Tile Processor</title>
  <style>
    canvas { border: 1px solid #ccc; display: block; margin-top: 1em; }
    label, input, button { margin: 0.5em; }
    #status { margin: 1em 0; font-style: italic; color: gray; }
  </style>
</head>
<body>
  <h2>Upload Image and Process as Tiled Output</h2>
  <input type="file" id="upload" accept="image/*">
  <label for="tilesX">Tiles across:</label>
  <input type="number" id="tilesX" value="20" min="1">
  <button id="processBtn" onclick="processImage()" disabled>Process Image</button>
  <div id="status">Loading palette...</div>
  <canvas id="preview"></canvas>

  <script>
    let palette = [];
    let imageReady = false;
    let paletteReady = false;
    let inputImage;

    const processBtn = document.getElementById('processBtn');
    const status = document.getElementById('status');

    function checkReady() {
      if (imageReady && paletteReady) {
        processBtn.disabled = false;
        status.textContent = "Ready to process.";
      } else if (!paletteReady) {
        status.textContent = "Loading palette...";
      } else {
        status.textContent = "Waiting for image upload...";
      }
    }

    fetch('palette.json')
      .then(response => response.json())
      .then(data => {
        palette = data;
        paletteReady = true;
        checkReady();
      })
      .catch(error => {
        status.textContent = "Failed to load palette.";
        console.error("Error loading palette:", error);
      });

    let originalCanvas = document.createElement('canvas');
    let originalCtx = originalCanvas.getContext('2d');

    document.getElementById('upload').addEventListener('change', function (e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function (event) {
        inputImage = new Image();
        inputImage.onload = () => {
          originalCanvas.width = inputImage.width;
          originalCanvas.height = inputImage.height;
          originalCtx.drawImage(inputImage, 0, 0);
          imageReady = true;
          checkReady();
        };
        inputImage.src = event.target.result;
      };
      reader.readAsDataURL(file);
    });

    function averageColor(data, startX, startY, tileW, tileH, imgWidth) {
      let r = 0, g = 0, b = 0, count = 0;
      for (let y = startY; y < startY + tileH; y++) {
        for (let x = startX; x < startX + tileW; x++) {
          let idx = (y * imgWidth + x) * 4;
          r += data[idx];
          g += data[idx + 1];
          b += data[idx + 2];
          count++;
        }
      }
      return { r: r / count, g: g / count, b: b / count };
    }

    function findClosestColor(color) {
      let bestMatch = palette[0];
      let minDist = Infinity;
      for (const p of palette) {
        let dist = (p.r - color.r) ** 2 + (p.g - color.g) ** 2 + (p.b - color.b) ** 2;
        if (dist < minDist) {
          minDist = dist;
          bestMatch = p;
        }
      }
      return bestMatch;
    }

    function getTextColor(r, g, b) {
      const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
      return luminance > 140 ? "black" : "white";
    }

    function processImage() {
      const tileW = 120;
      const tileH = 160;
      const imgW = inputImage.width;
      const imgH = inputImage.height;
      const tilesX = Math.floor(imgW / tileW);
      const tilesY = Math.floor(imgH / tileH);

      const ctx = originalCanvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, imgW, imgH).data;

      const preview = document.getElementById('preview');
      preview.width = tilesX * tileW;
      preview.height = tilesY * tileH;
      const pctx = preview.getContext('2d');

      const longestName = palette.reduce((a, b) => a.name.length > b.name.length ? a : b).name;
      let fontSize = tileW;
      do {
        fontSize--;
        pctx.font = `${fontSize}px sans-serif`;
      } while (pctx.measureText(longestName).width > tileW - 8);

      pctx.textAlign = "center";
      pctx.textBaseline = "top";

      for (let ty = 0; ty < tilesY; ty++) {
        for (let tx = 0; tx < tilesX; tx++) {
          const x = tx * tileW;
          const y = ty * tileH;
          const avg = averageColor(imageData, x, y, tileW, tileH, imgW);
          const best = findClosestColor(avg);

          pctx.fillStyle = `rgb(${best.r},${best.g},${best.b})`;
          pctx.fillRect(x, y, tileW, tileH);

          pctx.fillStyle = getTextColor(best.r, best.g, best.b);
          pctx.fillText(best.name, x + tileW / 2, y + 4);
        }
      }
    }
  </script>
</body>
</html>
